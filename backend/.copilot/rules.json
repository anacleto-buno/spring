{
  "version": "1.0",
  "rules": [
    {
      "description": "General coding style and conventions",
      "patterns": ["*.cs"],
      "guidelines": [
        "Follow .NET 9 and C# 13 conventions (PascalCase for public members, camelCase for locals/private fields).",
        "Prefer implicit typing (var) only when type is obvious from the right-hand side.",
        "Use string interpolation instead of concatenation.",
        "Use expression-bodied members for concise code when appropriate.",
        "Avoid unnecessary regions and comments; write self-explanatory code instead."
      ]
    },
    {
      "description": "Error handling and safety",
      "patterns": ["*.cs"],
      "guidelines": [
        "Use exceptions only for exceptional cases, not control flow.",
        "Validate all external input (API, DB, user).",
        "Use nullable reference types and always handle nullability explicitly.",
        "Log errors with structured logging (Serilog recommended).",
        "Apply the guard clause pattern to simplify precondition checks."
      ]
    },
    {
      "description": "Security best practices",
      "patterns": ["*.cs"],
      "guidelines": [
        "Never hardcode secrets; use Azure Key Vault or environment variables.",
        "Sanitize all user inputs to prevent injection attacks.",
        "Always use async I/O methods for external calls (DB, API, Files).",
        "Prefer HttpClientFactory for HTTP calls (Polly for resilience).",
        "Use the latest versions of Microsoft.Identity, System.Text.Json, and EF Core."
      ]
    },
    {
      "description": "Design patterns and architecture",
      "patterns": ["*.cs"],
      "guidelines": [
        "Favor dependency injection; avoid service locators or static dependencies.",
        "Keep controllers thin: business logic should live in services.",
        "Use repository + unit of work pattern for persistence.",
        "Apply CQRS for complex domains when separation of queries/commands is beneficial.",
        "Use record types for immutable DTOs and value objects."
      ]
    },
    {
      "description": "Testing and quality",
      "patterns": ["*.cs"],
      "guidelines": [
        "Write unit tests using xUnit and FluentAssertions.",
        "Use Moq or NSubstitute for mocking dependencies.",
        "Cover both happy path and edge cases.",
        "Prefer test-driven development (TDD) when possible.",
        "Keep tests isolated and independent; no hidden dependencies."
      ]
    },
    {
      "description": "Performance and optimization",
      "patterns": ["*.cs"],
      "guidelines": [
        "Use async/await throughout; avoid blocking calls (Task.Result, .Wait()).",
        "Prefer Span<T> and Memory<T> for high-performance data processing.",
        "Cache expensive computations and remote calls when possible (use IMemoryCache or Redis).",
        "Benchmark critical code paths with BenchmarkDotNet before optimizing.",
        "Avoid premature optimization; prioritize readability first."
      ]
    },
    {
      "description": "Libraries and tools",
      "patterns": ["*.csproj"],
      "guidelines": [
        "Use Entity Framework Core 9 for ORM.",
        "Use Serilog for logging.",
        "Use Polly for retries and circuit breakers.",
        "Use AutoMapper for object mapping when necessary (but avoid overuse).",
        "Use System.Text.Json instead of Newtonsoft.Json unless specific features are required."
      ]
    }
  ]
}
